<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	
	xmlns:georss="http://www.georss.org/georss"
	xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#"
	>

<channel>
	<title>books &#8211; Parerga und Paralipomena</title>
	<atom:link href="http://www.michelepasin.org/blog/tag/books/feed/" rel="self" type="application/rss+xml" />
	<link>http://www.michelepasin.org/blog</link>
	<description>At the core of all well-founded belief lies belief that is unfounded - Wittgenstein</description>
	<lastBuildDate>Wed, 10 Oct 2012 14:59:57 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.2.11</generator>
<site xmlns="com-wordpress:feed-additions:1">13825966</site>	<item>
		<title>Composing at the metalevel</title>
		<link>http://www.michelepasin.org/blog/2012/03/09/composing-at-the-metalevel/</link>
				<comments>http://www.michelepasin.org/blog/2012/03/09/composing-at-the-metalevel/#comments</comments>
				<pubDate>Fri, 09 Mar 2012 12:20:17 +0000</pubDate>
		<dc:creator><![CDATA[mikele]]></dc:creator>
				<category><![CDATA[Computer Music]]></category>
		<category><![CDATA[algorithmiccomposition]]></category>
		<category><![CDATA[books]]></category>
		<category><![CDATA[composition]]></category>
		<category><![CDATA[lisp]]></category>
		<category><![CDATA[taube]]></category>

		<guid isPermaLink="false">http://www.michelepasin.org/blog/?p=1109</guid>
				<description><![CDATA[I&#8217;ve started reading &#8220;Notes from the Metalevel: An Introduction to Computer Composition&#8220;, by Heinrich Taube, and realised I should have done that a long time ago! Notes From the Metalevel is a practical introduction to computer composition. It is primarily intended for student composers interested in learning how computation can provide them with a new [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>I&#8217;ve started reading &#8220;<a href="http://www.routledge.com/books/details/9789026519758/">Notes from the Metalevel: An Introduction to Computer Composition</a>&#8220;, by Heinrich Taube, and realised I should have done that a long time ago! </p>
<p><img src="http://images.tandf.co.uk/common/jackets/weblarge/978902651/9789026519758.jpg" /></p>
<blockquote><p>Notes From the Metalevel is a practical introduction to computer composition. It is primarily intended for student composers interested in learning how computation can provide them with a new paradigm for musical composition.
</p></blockquote>
<p>I happened to have a pdf version of the book, but the good news is that there&#8217;s an <a href="http://www.moz.ac.at/sem/lehre/lib/bib/software/cm/Notes_from_the_Metalevel/index.html">html version of it</a> too, which includes also all the midi files of the numerous examples included in the book. So make sure you check that out, if you&#8217;re interested in computer-based composition. You might also be interested in this <a href="http://www.computermusicjournal.org/reviews/29-3/phillips-taube.html">review on computer music journal</a>, and this <a href="http://camil.music.illinois.edu/Classes/404A1/">course materials</a> from Taube&#8217;s class at Illinois. </p>
<p>The preface to the fist chapter contains this suggestive excerpt from Leonard Schlain&#8217;s book, <em><a href="http://www.alphabetvsgoddess.com/index.html">The Alphabet Versus the Goddess</a></em>, which Taube (page 19-20) uses as a metaphor of what algorithmic composition (i.e., metalevel composition) is::</p>
<blockquote><p>&#8220;<em>The one crowded space in Father Perry&#8217;s house was his bookshelves. I gradually came to understand that the marks on the pages were trapped words. Anyone could learn to decipher the symbols and turn the trapped words loose again into speech. The ink of the print trapped the thoughts; they could no more get away than a doomboo could get out of a pit. When the full realization of what this meant flooded over me, I experienced the same thrill and amazement as when I had my first glimpse of the bright lights of Konakry. I shivered with the intensity of my desire to learn to do this wondrous thing myself.</em>&#8221;<br />
(spoken by Prince Modupe, a west African prince who learned to read as an adult)</p>
<p>It is impossible to know exactly how Prince Modupe felt when he discovered a process by which his very thoughts could be trapped and released at will again into speech. But I think his <strong>epiphany</strong> must be close to what I experienced when, as a young composer, I was first shown how I could <strong>use a computer to represent my musical ideas</strong> and then &#8220;release them&#8221; into musical compositions.<br />
At that instant it became clear to me that there was an <strong>entire level of notation above the scores</strong> that I had been writing in my regular composition classes, a level I knew nothing about! But I could see that in this level it was possible to notate my compositional ideas in a precise manner and work with them in an almost physical way, as &#8220;trapped words&#8221; that could be unleashed into musical sound whenever I wanted.
</p></blockquote>
<p>So what does it meant to compose at the meta level? </p>
<blockquote><p>
Given the existence of the acoustic and score representations one might ask if there is yet another representation that constitutes a level of abstraction above the performance score? The answer, of course, is yes; it is what this book terms the metalevel. If the score represents the composition then <strong>the metalevel represents the composition of the composition</strong>. A metalevel representation of music is concerned with representing the activity, or process, of musical composition as opposed to its artifact, or score.</p>
<p>This book is about <strong>using the computer to instantiate this level</strong>: to define, model and represent the compositional processes, formalism and structures that are articulated in a musical score and acoustic performance but are not literally represented there. By using a computer the composer can work with <strong>an explicit metalevel notation, or language, that makes the metalevel as tangible as the performance and acoustic levels</strong>.
</p></blockquote>
<p>&nbsp;</p>
]]></content:encoded>
							<wfw:commentRss>http://www.michelepasin.org/blog/2012/03/09/composing-at-the-metalevel/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
						<post-id xmlns="com-wordpress:feed-additions:1">1109</post-id>	</item>
		<item>
		<title>Python links (and more) 7/2/11</title>
		<link>http://www.michelepasin.org/blog/2011/02/03/python-links-and-more-7211/</link>
				<pubDate>Thu, 03 Feb 2011 15:23:21 +0000</pubDate>
		<dc:creator><![CDATA[mikele]]></dc:creator>
				<category><![CDATA[TechLife]]></category>
		<category><![CDATA[books]]></category>
		<category><![CDATA[conference]]></category>
		<category><![CDATA[culture]]></category>
		<category><![CDATA[django]]></category>
		<category><![CDATA[documentation]]></category>
		<category><![CDATA[google]]></category>
		<category><![CDATA[history]]></category>
		<category><![CDATA[hypertext]]></category>
		<category><![CDATA[museum]]></category>
		<category><![CDATA[narrative]]></category>
		<category><![CDATA[ontology]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[semanticweb]]></category>
		<category><![CDATA[spellchecking]]></category>
		<category><![CDATA[xml]]></category>

		<guid isPermaLink="false">http://www.michelepasin.org/blog/?p=1075</guid>
				<description><![CDATA[This post contains just a collection of various interesting things I ran into in the last couple of weeks&#8230; they&#8217;re organized into three categories: pythonic links, events and conferences, and new online tools. Hope you&#8217;ll find something of interest! Pythonic stuff: Epidoc Epydoc is a handy tool for generating API documentation for Python modules, based [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>This post contains just a collection of various interesting things I ran into in the last couple of weeks&#8230; they&#8217;re organized into three categories: pythonic links, events and conferences, and new online tools. Hope you&#8217;ll find something of interest!</p>
<h1></h1>
<h4 style="background:#e39191;">Pythonic stuff:</h4>
<li><a href="http://epydoc.sourceforge.net/manual-usage.html">Epidoc</a><br />
Epydoc is a handy tool for generating API <strong>documentation</strong> for Python modules, based on their docstrings. For an example of epydoc&#8217;s output, see the API documentation for epydoc itself (<a href="http://epydoc.sourceforge.net/api/">html</a>, <a href="http://epydoc.sourceforge.net/epydoc.pdf">pdf</a>).</li>
<li><a href="http://www.rfk.id.au/software/pyenchant/">PyEnchant</a><br />
PyEnchant is a <strong>spellchecking</strong> library for Python, based on the excellent <a href="http://www.abisource.com/enchant/">Enchant</a> library.</li>
<li><a href="http://pypi.python.org/pypi/dexml/">Dexml</a><br />
The dexml module takes the mapping between <strong>XML tags</strong> and Python objects and lets you capture that as cleanly as possible. Loosely inspired by Django&#8217;s ORM, you write simple class definitions to define the expected structure of your XML document.</li>
<li><a href="http://forge.morfeo-project.org/wiki_en/index.php/SpecGen">SpecGen</a><br />
SpecGen v5, <strong>ontology</strong> specification generator tool. It&#8217;s written in Python using Redland RDF library and licensed under the MIT license.</li>
<li><a href="http://www.picloud.com/">PyCloud</a><br />
Leverage the power of the <strong>cloud</strong> with only 3 lines of python code. Run long processes on the cloud directly from your shell!</li>
<li><a href="http://www.commandlinefu.com/commands/browse">commandlinefu.com</a><br />
This is not really pythonic &#8211; but nonetheless useful to pythonists: a community-based repository of useful unix <strong>shell</strong> scripts!</li>
<h1></h1>
<h4 style="background:#e39191;">Events and Conferences:</h4>
<li><a href="http://www.nottingham.ac.uk/drha/callforpapers.aspx">Digital Resources in the Humanities and Arts Conference 2011</a><br />
University of Nottingham Ningbo, China. The DRHA 2011 conference theme this year is &#8220;<strong>Connected Communities</strong>: global or local2local?&#8221;</li>
<li><a href="http://nht11.ecs.soton.ac.uk/">Narrative and Hypertext Workshop</a> at the ACM Hypertext 2011 <strong>conference</strong> in Eindhoven.
</li>
<li><a href="http://culturehackday.org.uk/">Culture Hack Day</a>, London, January 2011<br />
This <strong>event</strong> aimed at bringing cultural organisations together with software developers and creative technologists to make interesting new things. </li>
<li><a href="http://historyhackday.org/">History Hack Day</a>, London, January 2011<br />
A bunch of <strong>hackers</strong> with a passion for history getting together and doing experimental stuff</li>
<li><a href="https://conference.archimuse.com/">Conference.archimuse.com</a><br />
The &#8216;online space for <strong>cultural informatics</strong>&#8216;: lots of useful info here, about publications, jobs, people etc.
</li>
<li><a href="http://ec.europa.eu/information_society/apps/projects/factsheet/index.cfm?project_ref=270904">Agora project</a>: Scholarly Open Access Research in European Philosophy<br />
Project looking at building an infrastructure for the semantic interlinking of <strong>European philosophy</strong> datasets</li>
<h1></h1>
<h4 style="background:#e39191;">Online tools: </h4>
<li><a href="http://ontotext.com/factforge/reasonable-view.html">FactForge</a><br />
A web application aiming at showcasing a &#8216;practical approach for <strong>reasoning</strong> with the web of linked data&#8217;.</li>
<li><a href="http://www.semanticoverflow.com/">Semantic Overflow</a><br />
A clone of <a href="http://stackoverflow.com/">Stack Overflow</a> (collaboratively edited question and answer site for programmers) for <strong>questions</strong> &#8216;about semantic web techniques and technologies&#8217;.</li>
<li><a href="http://code.google.com/p/google-refine/">Google Refine</a><br />
A tool for &#8220;working with <strong>messy data</strong>, cleaning it up, transforming it from one format into another, extending it with web services, and linking it to databases&#8221;.
</li>
<li><a href="http://scribe.googlelabs.com/">Google Scribe</a><br />
A text <strong>editor</strong> with embedded autocomplete suggestions as you type</li>
<li><a href="http://ngrams.googlelabs.com/info">Books Ngram Viewer</a><br />
Tool that displays <strong>statistical</strong> information regarding the use of user-selected sentences in a corpus of books (e.g., &#8220;British English&#8221;, &#8220;English Fiction&#8221;, &#8220;French&#8221;) over the selected years</li>
<p>&#8230;</p>
]]></content:encoded>
									<post-id xmlns="com-wordpress:feed-additions:1">1075</post-id>	</item>
		<item>
		<title>Learning resources about Scheme</title>
		<link>http://www.michelepasin.org/blog/2010/08/10/learning-resources-about-scheme/</link>
				<pubDate>Tue, 10 Aug 2010 17:27:17 +0000</pubDate>
		<dc:creator><![CDATA[mikele]]></dc:creator>
				<category><![CDATA[Computer Music]]></category>
		<category><![CDATA[books]]></category>
		<category><![CDATA[impromptu]]></category>
		<category><![CDATA[learning]]></category>
		<category><![CDATA[scheme]]></category>

		<guid isPermaLink="false">http://www.michelepasin.org/blog/?p=808</guid>
				<description><![CDATA[&#8230; So you&#8217;ve decided to know everything about scheme and rock the world using fast-paced programming environments like Impromptu. Well, I confess I did think that on several occasions, but still I haven&#8217;t made it even half way through the schemer pilgmim&#8217;s path. But I&#8217;ve collected quite a few useful resources in the process, and [&#8230;]]]></description>
								<content:encoded><![CDATA[<p><a href="http://www.michelepasin.org/blog/wp-content/uploads/2010/08/3eangz5w.jpg"><img src="http://www.michelepasin.org/blog/wp-content/uploads/2010/08/3eangz5w.jpg" alt="3eangz5w.jpg" border="0" width="200" height="200" /></a><br />
&#8230;</p>
<p>So you&#8217;ve decided to know everything about scheme and rock the world using fast-paced programming environments like <a href="http://impromptu.moso.com.au/">Impromptu</a>.<br />
Well, I confess I did think that on several occasions, but still I haven&#8217;t made it even half way through the <em>schemer pilgmim&#8217;s path</em>. But I&#8217;ve collected quite a few useful resources in the process, and those I can certainly share! </p>
<p>So in what follows I&#8217;ve put together a list of learning resources about Scheme that I found useful.. First off, two links that might be useful in all situations:</p>
<li><a href="http://www.crockford.com/javascript/scheme.html">Little Scheme</a>, an online interpreter that you can use for testing things out while you&#8217;re on holidays</li>
<li><a href="http://www.schemers.org/">Schemers.org</a>, semi-official website containing news and lots of links to other resources</li>
<p>Now, why don&#8217;t we start with the definition offered by the self-regulating <a href="http://en.wikipedia.org/wiki/Scheme_programming_language">wikipedia</a> collective intelligence? Here we go:</p>
<blockquote><p>Scheme is one of the two main <strong>dialects</strong> of the programming language <strong>Lisp</strong>. Unlike Common Lisp, the other main dialect, Scheme follows a <strong>minimalist design philosophy</strong> specifying a small standard core with powerful tools for language extension. Its compactness and elegance have made it <strong>popular with educators, language designers, programmers, implementors, and hobbyists</strong>, and this diverse appeal is seen as both a strength and, because of the diversity of its constituencies and the wide divergence between implementations, one of its weaknesses</p></blockquote>
<p>If this blurb hasn&#8217;t made you proud of learning such a slick language, you&#8217;ll surely find more interesting ideas in what follows. I divided up the list in two sections, generic learning materials about scheme, and tutorials about specific topics (for now, only macros are included).<br />
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-</p>
<h3>1. Learning Resources About Scheme:</h3>
<li><a href="http://www.accesscom.com/~darius/writings/scheme-for-lispers.html">Scheme for Common Lispers</a>, article<br />
<blockquote><p>The Scheme dialect of Lisp was created in 1975 by Guy Steele and Gerry Sussman to explore ideas in programming-language semantics. They showed that a powerful language can be made &#8220;not by piling feature on top of feature, but by removing the weaknesses and restrictions that make additional features appear necessary&#8221;. Scheme pioneered lexical scope in Lisp, first-class continuations, and tail recursion, and more recently added an advanced macro system. It&#8217;s the best-known Lisp dialect after Common Lisp (which it influenced).<br />
<strong>This note summarizes the differences from CL that might slow down a CL programmer trying to read a Scheme program</strong>; people without a CL background, or wanting to write programs of their own, should see the references.</p></blockquote>
</li>
<li><a href="http://schemecookbook.org/">the Schematics Scheme Cookbook </a><br />
<blockquote><p>The Schematics Scheme Cookbook is a <strong>collaborative effort to produce documentation and recipes for using Scheme for common tasks</strong>. See the BookIntroduction for more information on the Cookbook&#8217;s goals, and the important ContributorAgreement statement.</p></blockquote>
</li>
<li>Harvey, Wright, <a href="http://www.cs.berkeley.edu/~bh/ss-toc2.html">Simply Scheme: Introducing Computer Science</a>, 1999 MIT press [<em>a classic</em>]<br />
<blockquote><p><strong>Symbolic programming</strong> is one aspect of the reason why we like to teach computer science using Scheme instead of a more traditional language. More generally, Lisp (and therefore Scheme) was designed to support what we&#8217;ve called the radical view of computer science. In this view, <strong>computer science is about tools for expressing ideas</strong>. Symbolic programming allows the computer to express ideas; other aspects of Lisp&#8217;s design help the programmer express ideas conveniently. Sometimes that goal comes in conflict with the conservative computer scientist&#8217;s goal of protection against errors.</p></blockquote>
</li>
<li>Felleisen, Findler, Flatt, Krishnamurthi, <a href="http://www.htdp.org/">How to Design Programs An Introduction to Computing and Programming</a>, MIT 2001<br />
<blockquote><p>[..]  programming is more than just a vocational skill. Indeed, <strong>good programming is a fun activity, a creative outlet, and a way to express abstract ideas in a tangible form.</strong> And designing programs teaches a variety of skills that are important in all kinds of professions: critical reading, analytical thinking, creative synthesis, and attention to detail.<br />
We therefore believe that the study of program design deserves the same central role in general education as mathematics and English. Or, put more succinctly, <strong>everyone should learn how to design programs</strong>.<br />
On one hand, program design teaches the same analytical skills as mathematics. But, unlike mathematics, <strong>working with programs is an active approach to learning</strong>. Interacting with software provides immediate feedback and thus leads to exploration, experimentation, and self-evaluation. Furthermore, designing programs produces useful and fun things, which vastly increases the sense of accomplishment when compared to drill exercises in mathematics. On the other hand, program design teaches the same analytical reading and writing skills as English. Even the smallest programming tasks are formulated as word problems. Without critical reading skills, a student cannot design programs that match the specification. Conversely, good program design methods force a student to articulate thoughts about programs in proper English.</p></blockquote>
</li>
<li>Dybvig, <a href="http://www.scheme.com/tspl3/">The Scheme Programming Language</a>, 2003MIT press<br />
<blockquote><p>This book is intended to provide an <strong>introduction to the Scheme programming language but not an introduction to programming in general</strong>. The reader is expected to have had some experience programming and to be familiar with terms commonly associated with computers and programming languages. The author recommends that readers unfamiliar with Scheme or Lisp also read The Little Schemer [<em>see below</em>]to become familiar with the concepts of list processing and recursion. Readers new to programming should begin with an introductory text on programming.</p></blockquote>
</li>
<li>Nils M Holm, &#8220;<a href="http://www.amazon.com/Sketchy-LISP-Nils-M-Holm/dp/1411674480">Sketchy LISP</a>&#8221; [you can <del>download the book here</del> Update 08/12: this book has become &#8216;Sketchy Scheme&#8217; and is now <a href="http://www.lulu.com/shop/nils-m-holm/sketchy-scheme/paperback/product-15591311.html">for-sale here</a>]<br />
<blockquote><p>Sketchy LISP is a <strong>step-by-step introduction to functional programming</strong> in Scheme. It covers various aspects of the language including data types, conditional evaluation, list processing, lexical scoping, closures, recursion, dynamic typing, etc. By means of numerous examples of varying complexity, it takes the reader on an entertaining and informative tour through the language.<br />
The Scheme language achieves what only few languages have managed before: to <strong>bring fun back to programming</strong>. Its simple syntax, clean semantics, and powerful functions open the door to a fresh perspective on program design. Programming in Scheme is fun, and this book is an attempt to share some of that fun.</p></blockquote>
</li>
<li>Friedman and Felleisen, <a href="http://www.ccs.neu.edu/home/matthias/BTLS/">The Little Schemer</a>, 1996 MIT press<br />
<blockquote><p>The goal of this book is to <strong>teach the reader to think recursively</strong>. Our first task, therefore, is to decide which language to use to communicate this concept. There are three obvious choices: a natural language, such as English; formal mathematics; or a programming language. Natural languages are ambiguous, imprecise, and sometimes awkwardly verbose. These are all virtues for general communication, but something of a drawback for communicating concisely as precise a concept as the power of recursion. The language of mathematics is the opposite of natural language: it can express powerful formal ideas with only a few symbols. We could, for example, describe the entire technical content of this book in less than a page of mathematics, but the reader who understands that page has little need for this book. For most people, formal mathematics is not very intuitive. <strong>The marriage of technology and mathematics presents us with a third, almost ideal choice: a programming language.</strong> Programming languages are perhaps the best way to convey the concept of recursion. They share with mathematics the ability to give a formal meaning to a set of symbols. But unlike mathematics, programming languages can be directly experienced&#8212;you can take the programs in this book and try them, observe their behavior, modify them, and experience the effect of your modifications.</p></blockquote>
</li>
<li><a href="http://wla.berkeley.edu/">The Weiner Lectures Archives</a> [various videos, but not complete lectures unfortunately]<br />
<blockquote><p>The goal of this project is to make knowledge of computer science easily available not only to the students at Berkeley, but also to the entire community. For several years, faculty members have been videotaping lectures in CS large lower division courses, mainly as an aid to students with time conflicts that prevent them from attending lectures. By <strong>hosting an archive storing all CS lectures that were recorded</strong>, we hope the computing knowledge that has been gathered can be easily shared. As a teaching aid, a &#8216;greatest hits&#8217; lecture will also be compiled for each course covering all major topics addressed in the corresponding class. The best parts of many different past lectures will be linked together and presented along with slides to make this greatest hits lecture. This lecture should represent the best teaching abilities in the lower division CS lectures and should be a valuable resource in the computer community for basic CS knowledge. Thanks to the generous donation of Larry Weiner this online site should become a permanent resource.</p></blockquote>
</li>
<p>&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-</p>
<h3>2. Specific topics: </h3>
<h4>On Macros and metaprogramming:</h4>
<li><a href="http://www.ibm.com/developerworks/linux/library/l-metaprog1.html">The art of metaprogramming, Part 1: Introduction to metaprogramming</a>, IBM developer works<br />
<blockquote><p>Summary:  One of the most under-used programming techniques is <strong>writing programs that generate programs or program parts</strong>. Learn why metaprogramming is necessary and look at some of the components of metaprogramming (textual macro languages, specialized code generators). See how to build a code generator and get a closer look at language-sensitive macro programming in Scheme.</p></blockquote>
</li>
<li><a href="http://nostoc.stanford.edu/Docs/livetutorials/macros.html">Lisp Macros &#8212; How to Define Entirely New Languages in Lisp</a><br />
<blockquote><p>This is a very interesting lesson if you want to deeply understand Lisp, and some very deep things about programming, but it&#8217;s also entirely optional; We suggest that you do through it, but not worry too much about understanding it in detail. If you get very deeply into programming, you&#8217;ll find that Lisp macros are an amazing tool, but they are also somewhat <strong>mind-bending</strong>, and used rather rarely in simple programming. So, feel free to skip this lesson, or at least, if you do study it, let it flow over you, and maybe come back to it later on if you find yourself wanting to know more about some of the deep and subtle reaches of Lisp programming.</p></blockquote>
</li>
<li><a href="http://community.schemewiki.org/?scheme-faq-macros">Scheme FAQ Macros</a>, on schemewiki.org</li>
<li><a href="http://stackoverflow.com/questions/131433/sources-for-learning-about-scheme-macros-define-syntax-and-syntax-rules">Sources for learning about Scheme Macros: define-syntax and syntax-rules</a>, a thread on StackOverflow</li>
<li><a href="http://blog.willdonnelly.net/2008/09/04/a-scheme-syntax-rules-primer/">A scheme syntax rules primer</a>, an interesting blog post</li>
<p>&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-</p>
<p>That&#8217;s all for now&#8230; I&#8217;ll be adding more stuff as I run into it!</p>
]]></content:encoded>
									<post-id xmlns="com-wordpress:feed-additions:1">808</post-id>	</item>
	</channel>
</rss>
